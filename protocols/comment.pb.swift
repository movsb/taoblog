// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocols/comment.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 内容渲染选项。
struct Protocols_PostContentOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 要不要内容？
  var withContent: Bool = false

  /// 保留 #一级标题？
  /// 几乎只有在文章编辑预览的时候用得着，所以默认不保留。
  var keepTitleHeading: Bool = false

  /// 要不要渲染代码 (成 HTML）？
  var renderCodeBlocks: Bool = false

  /// 文章中的相对链接改成使用绝对链接
  var useAbsolutePaths: Bool = false

  /// 要不要生成美化后的结果？
  var prettifyHtml: Bool = false

  /// 新窗口打开链接？
  var openLinksInNewTab: Protocols_PostContentOptions.OpenLinkInNewTabKind = .keep

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OpenLinkInNewTabKind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case keep // = 0
    case never // = 1
    case all // = 2
    case external // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .keep
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .keep
      case 1: self = .never
      case 2: self = .all
      case 3: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .keep: return 0
      case .never: return 1
      case .all: return 2
      case .external: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Protocols_PostContentOptions.OpenLinkInNewTabKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Protocols_PostContentOptions.OpenLinkInNewTabKind] = [
    .keep,
    .never,
    .all,
    .external,
  ]
}

#endif  // swift(>=4.2)

struct Protocols_Comment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var parent: Int64 {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  var root: Int64 {
    get {return _storage._root}
    set {_uniqueStorage()._root = newValue}
  }

  var postID: Int64 {
    get {return _storage._postID}
    set {_uniqueStorage()._postID = newValue}
  }

  var author: String {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  var date: Int32 {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  var sourceType: String {
    get {return _storage._sourceType}
    set {_uniqueStorage()._sourceType = newValue}
  }

  var source: String {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var isAdmin: Bool {
    get {return _storage._isAdmin}
    set {_uniqueStorage()._isAdmin = newValue}
  }

  var dateFuzzy: String {
    get {return _storage._dateFuzzy}
    set {_uniqueStorage()._dateFuzzy = newValue}
  }

  var geoLocation: String {
    get {return _storage._geoLocation}
    set {_uniqueStorage()._geoLocation = newValue}
  }

  /// 前端用户是否可以编辑此评论？
  /// 仅在 list/create 接口中返回。
  var canEdit: Bool {
    get {return _storage._canEdit}
    set {_uniqueStorage()._canEdit = newValue}
  }

  /// 头像内部临时ID
  var avatar: Int32 {
    get {return _storage._avatar}
    set {_uniqueStorage()._avatar = newValue}
  }

  var modified: Int32 {
    get {return _storage._modified}
    set {_uniqueStorage()._modified = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocols_GetCommentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_UpdateCommentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var comment: Protocols_Comment {
    get {return _comment ?? Protocols_Comment()}
    set {_comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  var hasComment: Bool {return self._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  mutating func clearComment() {self._comment = nil}

  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _comment: Protocols_Comment? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

struct Protocols_DeleteCommentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_DeleteCommentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_ListCommentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: Protocols_ListCommentsRequest.Mode = .unspecified

  /// 0 for all posts.
  var postID: Int64 = 0

  /// defaults to "*".
  var fields: [String] = []

  /// must be > 0.
  var limit: Int64 = 0

  var offset: Int64 = 0

  var orderBy: String = String()

  /// 文章的种类，比如 post、page、tweet。
  /// 如果不指定的话，则是全部种类。
  var types: [String] = []

  var contentOptions: Protocols_PostContentOptions {
    get {return _contentOptions ?? Protocols_PostContentOptions()}
    set {_contentOptions = newValue}
  }
  /// Returns true if `contentOptions` has been explicitly set.
  var hasContentOptions: Bool {return self._contentOptions != nil}
  /// Clears the value of `contentOptions`. Subsequent reads from it will return its default value.
  mutating func clearContentOptions() {self._contentOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Mode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// limit 控制顶级评论的数量，子评论全部返回。用于以树型结构展示。
    case tree // = 1

    /// limit 控制全部评论的数量，不区分父子评论。用于平铺展示近期评论。
    case flat // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .tree
      case 2: self = .flat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .tree: return 1
      case .flat: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _contentOptions: Protocols_PostContentOptions? = nil
}

#if swift(>=4.2)

extension Protocols_ListCommentsRequest.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Protocols_ListCommentsRequest.Mode] = [
    .unspecified,
    .tree,
    .flat,
  ]
}

#endif  // swift(>=4.2)

struct Protocols_ListCommentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var comments: [Protocols_Comment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_SetCommentPostIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var postID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_SetCommentPostIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_PreviewCommentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var markdown: String = String()

  /// 所属文章编号。不是必须的。
  /// 但是为了计算图片的大小，建议加上。
  var postID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_PreviewCommentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var html: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocols_PostContentOptions: @unchecked Sendable {}
extension Protocols_PostContentOptions.OpenLinkInNewTabKind: @unchecked Sendable {}
extension Protocols_Comment: @unchecked Sendable {}
extension Protocols_GetCommentRequest: @unchecked Sendable {}
extension Protocols_UpdateCommentRequest: @unchecked Sendable {}
extension Protocols_DeleteCommentRequest: @unchecked Sendable {}
extension Protocols_DeleteCommentResponse: @unchecked Sendable {}
extension Protocols_ListCommentsRequest: @unchecked Sendable {}
extension Protocols_ListCommentsRequest.Mode: @unchecked Sendable {}
extension Protocols_ListCommentsResponse: @unchecked Sendable {}
extension Protocols_SetCommentPostIDRequest: @unchecked Sendable {}
extension Protocols_SetCommentPostIDResponse: @unchecked Sendable {}
extension Protocols_PreviewCommentRequest: @unchecked Sendable {}
extension Protocols_PreviewCommentResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocols"

extension Protocols_PostContentOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostContentOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "with_content"),
    2: .standard(proto: "keep_title_heading"),
    3: .standard(proto: "render_code_blocks"),
    4: .standard(proto: "use_absolute_paths"),
    5: .standard(proto: "prettify_html"),
    6: .standard(proto: "open_links_in_new_tab"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.withContent) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepTitleHeading) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.renderCodeBlocks) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.useAbsolutePaths) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.prettifyHtml) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.openLinksInNewTab) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.withContent != false {
      try visitor.visitSingularBoolField(value: self.withContent, fieldNumber: 1)
    }
    if self.keepTitleHeading != false {
      try visitor.visitSingularBoolField(value: self.keepTitleHeading, fieldNumber: 2)
    }
    if self.renderCodeBlocks != false {
      try visitor.visitSingularBoolField(value: self.renderCodeBlocks, fieldNumber: 3)
    }
    if self.useAbsolutePaths != false {
      try visitor.visitSingularBoolField(value: self.useAbsolutePaths, fieldNumber: 4)
    }
    if self.prettifyHtml != false {
      try visitor.visitSingularBoolField(value: self.prettifyHtml, fieldNumber: 5)
    }
    if self.openLinksInNewTab != .keep {
      try visitor.visitSingularEnumField(value: self.openLinksInNewTab, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_PostContentOptions, rhs: Protocols_PostContentOptions) -> Bool {
    if lhs.withContent != rhs.withContent {return false}
    if lhs.keepTitleHeading != rhs.keepTitleHeading {return false}
    if lhs.renderCodeBlocks != rhs.renderCodeBlocks {return false}
    if lhs.useAbsolutePaths != rhs.useAbsolutePaths {return false}
    if lhs.prettifyHtml != rhs.prettifyHtml {return false}
    if lhs.openLinksInNewTab != rhs.openLinksInNewTab {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_PostContentOptions.OpenLinkInNewTabKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OpenLinkInNewTabKindKeep"),
    1: .same(proto: "OpenLinkInNewTabKindNever"),
    2: .same(proto: "OpenLinkInNewTabKindAll"),
    3: .same(proto: "OpenLinkInNewTabKindExternal"),
  ]
}

extension Protocols_Comment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Comment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "parent"),
    3: .same(proto: "root"),
    4: .standard(proto: "post_id"),
    5: .same(proto: "author"),
    6: .same(proto: "email"),
    7: .same(proto: "url"),
    8: .same(proto: "ip"),
    9: .same(proto: "date"),
    10: .standard(proto: "source_type"),
    11: .same(proto: "source"),
    12: .same(proto: "content"),
    14: .standard(proto: "is_admin"),
    15: .standard(proto: "date_fuzzy"),
    16: .standard(proto: "geo_location"),
    17: .standard(proto: "can_edit"),
    18: .same(proto: "avatar"),
    19: .same(proto: "modified"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _parent: Int64 = 0
    var _root: Int64 = 0
    var _postID: Int64 = 0
    var _author: String = String()
    var _email: String = String()
    var _url: String = String()
    var _ip: String = String()
    var _date: Int32 = 0
    var _sourceType: String = String()
    var _source: String = String()
    var _content: String = String()
    var _isAdmin: Bool = false
    var _dateFuzzy: String = String()
    var _geoLocation: String = String()
    var _canEdit: Bool = false
    var _avatar: Int32 = 0
    var _modified: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _parent = source._parent
      _root = source._root
      _postID = source._postID
      _author = source._author
      _email = source._email
      _url = source._url
      _ip = source._ip
      _date = source._date
      _sourceType = source._sourceType
      _source = source._source
      _content = source._content
      _isAdmin = source._isAdmin
      _dateFuzzy = source._dateFuzzy
      _geoLocation = source._geoLocation
      _canEdit = source._canEdit
      _avatar = source._avatar
      _modified = source._modified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._parent) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._root) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._postID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._ip) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._date) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sourceType) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isAdmin) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._dateFuzzy) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._geoLocation) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._canEdit) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._avatar) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._modified) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._parent != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parent, fieldNumber: 2)
      }
      if _storage._root != 0 {
        try visitor.visitSingularInt64Field(value: _storage._root, fieldNumber: 3)
      }
      if _storage._postID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._postID, fieldNumber: 4)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularStringField(value: _storage._author, fieldNumber: 5)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 8)
      }
      if _storage._date != 0 {
        try visitor.visitSingularInt32Field(value: _storage._date, fieldNumber: 9)
      }
      if !_storage._sourceType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceType, fieldNumber: 10)
      }
      if !_storage._source.isEmpty {
        try visitor.visitSingularStringField(value: _storage._source, fieldNumber: 11)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 12)
      }
      if _storage._isAdmin != false {
        try visitor.visitSingularBoolField(value: _storage._isAdmin, fieldNumber: 14)
      }
      if !_storage._dateFuzzy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dateFuzzy, fieldNumber: 15)
      }
      if !_storage._geoLocation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._geoLocation, fieldNumber: 16)
      }
      if _storage._canEdit != false {
        try visitor.visitSingularBoolField(value: _storage._canEdit, fieldNumber: 17)
      }
      if _storage._avatar != 0 {
        try visitor.visitSingularInt32Field(value: _storage._avatar, fieldNumber: 18)
      }
      if _storage._modified != 0 {
        try visitor.visitSingularInt32Field(value: _storage._modified, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_Comment, rhs: Protocols_Comment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._root != rhs_storage._root {return false}
        if _storage._postID != rhs_storage._postID {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._ip != rhs_storage._ip {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._sourceType != rhs_storage._sourceType {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._isAdmin != rhs_storage._isAdmin {return false}
        if _storage._dateFuzzy != rhs_storage._dateFuzzy {return false}
        if _storage._geoLocation != rhs_storage._geoLocation {return false}
        if _storage._canEdit != rhs_storage._canEdit {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._modified != rhs_storage._modified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCommentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetCommentRequest, rhs: Protocols_GetCommentRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_UpdateCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateCommentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comment"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._comment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._comment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_UpdateCommentRequest, rhs: Protocols_UpdateCommentRequest) -> Bool {
    if lhs._comment != rhs._comment {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_DeleteCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteCommentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_DeleteCommentRequest, rhs: Protocols_DeleteCommentRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_DeleteCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteCommentResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_DeleteCommentResponse, rhs: Protocols_DeleteCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_ListCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCommentsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .standard(proto: "post_id"),
    3: .same(proto: "fields"),
    4: .same(proto: "limit"),
    5: .same(proto: "offset"),
    6: .standard(proto: "order_by"),
    10: .same(proto: "types"),
    11: .standard(proto: "content_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.postID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.fields) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._contentOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.postID != 0 {
      try visitor.visitSingularInt64Field(value: self.postID, fieldNumber: 2)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fields, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 10)
    }
    try { if let v = self._contentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_ListCommentsRequest, rhs: Protocols_ListCommentsRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.types != rhs.types {return false}
    if lhs._contentOptions != rhs._contentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_ListCommentsRequest.Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unspecified"),
    1: .same(proto: "Tree"),
    2: .same(proto: "Flat"),
  ]
}

extension Protocols_ListCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCommentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_ListCommentsResponse, rhs: Protocols_ListCommentsResponse) -> Bool {
    if lhs.comments != rhs.comments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_SetCommentPostIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetCommentPostIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "post_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.postID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.postID != 0 {
      try visitor.visitSingularInt64Field(value: self.postID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_SetCommentPostIDRequest, rhs: Protocols_SetCommentPostIDRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_SetCommentPostIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetCommentPostIDResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_SetCommentPostIDResponse, rhs: Protocols_SetCommentPostIDResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_PreviewCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreviewCommentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "markdown"),
    2: .standard(proto: "post_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.markdown) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.postID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.markdown.isEmpty {
      try visitor.visitSingularStringField(value: self.markdown, fieldNumber: 1)
    }
    if self.postID != 0 {
      try visitor.visitSingularInt32Field(value: self.postID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_PreviewCommentRequest, rhs: Protocols_PreviewCommentRequest) -> Bool {
    if lhs.markdown != rhs.markdown {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_PreviewCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreviewCommentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "html"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.html) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.html.isEmpty {
      try visitor.visitSingularStringField(value: self.html, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_PreviewCommentResponse, rhs: Protocols_PreviewCommentResponse) -> Bool {
    if lhs.html != rhs.html {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
