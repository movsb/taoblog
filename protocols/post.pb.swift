// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocols/post.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Protocols_LinkKind: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case rooted // = 1
  case full // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .rooted
    case 2: self = .full
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .rooted: return 1
    case .full: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocols_LinkKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Protocols_LinkKind] = [
    .none,
    .rooted,
    .full,
  ]
}

#endif  // swift(>=4.2)

struct Protocols_Metas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO：以下两者应该由 style.css 和 script.js 等独立文件实现。
  /// 置于 <head> 最后的。
  var header: String = String()

  /// 置于 <body> 最后的。
  var footer: String = String()

  /// 文章是否已经过时。
  var outdated: Bool = false

  /// 是否以宽屏模式显示内容。
  var wide: Bool = false

  /// 文章附件来源。
  /// 第一个参数是相对路径。
  var sources: Dictionary<String,Protocols_Metas.Source> = [:]

  /// 地理位置信息。
  var geo: Protocols_Metas.Geo {
    get {return _geo ?? Protocols_Metas.Geo()}
    set {_geo = newValue}
  }
  /// Returns true if `geo` has been explicitly set.
  var hasGeo: Bool {return self._geo != nil}
  /// Clears the value of `geo`. Subsequent reads from it will return its default value.
  mutating func clearGeo() {self._geo = nil}

  /// 文章原始来源信息
  var origin: Protocols_Metas.Origin {
    get {return _origin ?? Protocols_Metas.Origin()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  /// 微信短链接。形如："-UWZEu5Z74DZgRzKksTBtw"。
  /// TODO 合并进 Origin。
  var weixin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Source {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var url: String = String()

    var description_p: String = String()

    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Geo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var longitude: Float = 0

    var latitude: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Origin {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 来源平台。
    var platform: Protocols_Metas.Origin.Platform = .originUnspecified

    /// 唯一ID编成部分。
    var slugs: [String] = []

    /// 描述。
    var description_p: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Platform: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case originUnspecified // = 0
      case twitter // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .originUnspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .originUnspecified
        case 1: self = .twitter
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .originUnspecified: return 0
        case .twitter: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}

  fileprivate var _geo: Protocols_Metas.Geo? = nil
  fileprivate var _origin: Protocols_Metas.Origin? = nil
}

#if swift(>=4.2)

extension Protocols_Metas.Origin.Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Protocols_Metas.Origin.Platform] = [
    .originUnspecified,
    .twitter,
  ]
}

#endif  // swift(>=4.2)

struct Protocols_Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var date: Int32 {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  var modified: Int32 {
    get {return _storage._modified}
    set {_uniqueStorage()._modified = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var category: Int64 {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var pageView: Int64 {
    get {return _storage._pageView}
    set {_uniqueStorage()._pageView = newValue}
  }

  var commentStatus: Bool {
    get {return _storage._commentStatus}
    set {_uniqueStorage()._commentStatus = newValue}
  }

  var comments: Int64 {
    get {return _storage._comments}
    set {_uniqueStorage()._comments = newValue}
  }

  var metas: Protocols_Metas {
    get {return _storage._metas ?? Protocols_Metas()}
    set {_uniqueStorage()._metas = newValue}
  }
  /// Returns true if `metas` has been explicitly set.
  var hasMetas: Bool {return _storage._metas != nil}
  /// Clears the value of `metas`. Subsequent reads from it will return its default value.
  mutating func clearMetas() {_uniqueStorage()._metas = nil}

  var source: String {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  var sourceType: String {
    get {return _storage._sourceType}
    set {_uniqueStorage()._sourceType = newValue}
  }

  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// ~~文章最后被评论的时间~~。
  /// 更新：文章的评论最后有更新（包括：创建、更新、删除）的时间。
  /// 与文章的更新时间一起贡献给 304 处理函数。
  /// 这个值可以是空的，表示没有被评论过。（更新：也可能表示数据库升级开始后没有评论过）
  /// TODO 考虑换个名字了。
  var lastCommentedAt: Int32 {
    get {return _storage._lastCommentedAt}
    set {_uniqueStorage()._lastCommentedAt = newValue}
  }

  /// 相关文章列表。
  /// 数量固定。
  /// 仅在 GetPost 时指定选项后返回。
  /// 只有 id 和 title 有效。
  var relates: [Protocols_Post] {
    get {return _storage._relates}
    set {_uniqueStorage()._relates = newValue}
  }

  /// 文章的链接。
  var link: String {
    get {return _storage._link}
    set {_uniqueStorage()._link = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocols_GetPostRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 选择其一。
  var id: Int32 = 0

  var page: String = String()

  /// 是否包含“相关文章”。
  var withRelates: Bool = false

  var contentOptions: Protocols_PostContentOptions {
    get {return _contentOptions ?? Protocols_PostContentOptions()}
    set {_contentOptions = newValue}
  }
  /// Returns true if `contentOptions` has been explicitly set.
  var hasContentOptions: Bool {return self._contentOptions != nil}
  /// Clears the value of `contentOptions`. Subsequent reads from it will return its default value.
  mutating func clearContentOptions() {self._contentOptions = nil}

  var withLink: Protocols_LinkKind = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contentOptions: Protocols_PostContentOptions? = nil
}

struct Protocols_UpdatePostRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var post: Protocols_Post {
    get {return _post ?? Protocols_Post()}
    set {_post = newValue}
  }
  /// Returns true if `post` has been explicitly set.
  var hasPost: Bool {return self._post != nil}
  /// Clears the value of `post`. Subsequent reads from it will return its default value.
  mutating func clearPost() {self._post = nil}

  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  /// 默认 modified 已被用作防冲突的版本号。
  /// touch 可以用来控制是否更新 modified 为当前时间。
  /// 默认为 false，表示要更新。
  var doNotTouch: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _post: Protocols_Post? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

struct Protocols_DeletePostRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_ListPostsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limit: Int32 = 0

  var orderBy: String = String()

  var contentOptions: Protocols_PostContentOptions {
    get {return _contentOptions ?? Protocols_PostContentOptions()}
    set {_contentOptions = newValue}
  }
  /// Returns true if `contentOptions` has been explicitly set.
  var hasContentOptions: Bool {return self._contentOptions != nil}
  /// Clears the value of `contentOptions`. Subsequent reads from it will return its default value.
  mutating func clearContentOptions() {self._contentOptions = nil}

  var kinds: [String] = []

  var withLink: Protocols_LinkKind = .none

  /// 如果 > 0，则只会列出从这个时间点开始、结束的文章。
  /// 以后有过更新的文章，适用于备份用。
  /// 时间范围：[NotBefore, NotAfter)。
  var modifiedNotBefore: Int32 = 0

  var modifiedNotAfter: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contentOptions: Protocols_PostContentOptions? = nil
}

struct Protocols_ListPostsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var posts: [Protocols_Post] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_GetPostCommentsCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var postID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_GetPostCommentsCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var count: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_SetPostStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var `public`: Bool = false

  /// Whether to create_time and update_time
  var touch: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_SetPostStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 获取某篇文章的全部评论。
struct Protocols_GetPostCommentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_GetPostCommentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var comments: [Protocols_Comment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_GetPostsByTagsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tags: [String] = []

  var contentOptions: Protocols_PostContentOptions {
    get {return _contentOptions ?? Protocols_PostContentOptions()}
    set {_contentOptions = newValue}
  }
  /// Returns true if `contentOptions` has been explicitly set.
  var hasContentOptions: Bool {return self._contentOptions != nil}
  /// Clears the value of `contentOptions`. Subsequent reads from it will return its default value.
  mutating func clearContentOptions() {self._contentOptions = nil}

  var withLink: Protocols_LinkKind = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contentOptions: Protocols_PostContentOptions? = nil
}

struct Protocols_GetPostsByTagsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var posts: [Protocols_Post] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_PreviewPostRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var markdown: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_PreviewPostResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var html: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_CheckPostTaskListItemsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 文章编号
  var id: Int32 = 0

  /// 文章修改时间，用于版本同步。
  var postModificationTime: Int32 = 0

  /// 任务列表。
  var checks: [Int32] = []

  var unchecks: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_CheckPostTaskListItemsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 只会返回基础信息。
  var post: Protocols_Post {
    get {return _post ?? Protocols_Post()}
    set {_post = newValue}
  }
  /// Returns true if `post` has been explicitly set.
  var hasPost: Bool {return self._post != nil}
  /// Clears the value of `post`. Subsequent reads from it will return its default value.
  mutating func clearPost() {self._post = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _post: Protocols_Post? = nil
}

struct Protocols_FileSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var mode: UInt32 = 0

  var size: UInt32 = 0

  var time: UInt32 = 0

  /// 文件内容类型。
  /// 仅在 list 的时候返回，其它时候不使用。
  /// 仅通过后缀名判断，可能为空。
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocols_FileSystemRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var init_p: Protocols_FileSystemRequest.InitRequest {
    get {return _init_p ?? Protocols_FileSystemRequest.InitRequest()}
    set {_init_p = newValue}
  }
  /// Returns true if `init_p` has been explicitly set.
  var hasInit_p: Bool {return self._init_p != nil}
  /// Clears the value of `init_p`. Subsequent reads from it will return its default value.
  mutating func clearInit_p() {self._init_p = nil}

  var request: Protocols_FileSystemRequest.OneOf_Request? = nil

  var listFiles: Protocols_FileSystemRequest.ListFilesRequest {
    get {
      if case .listFiles(let v)? = request {return v}
      return Protocols_FileSystemRequest.ListFilesRequest()
    }
    set {request = .listFiles(newValue)}
  }

  var writeFile: Protocols_FileSystemRequest.WriteFileRequest {
    get {
      if case .writeFile(let v)? = request {return v}
      return Protocols_FileSystemRequest.WriteFileRequest()
    }
    set {request = .writeFile(newValue)}
  }

  var deleteFile: Protocols_FileSystemRequest.DeleteFileRequest {
    get {
      if case .deleteFile(let v)? = request {return v}
      return Protocols_FileSystemRequest.DeleteFileRequest()
    }
    set {request = .deleteFile(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case listFiles(Protocols_FileSystemRequest.ListFilesRequest)
    case writeFile(Protocols_FileSystemRequest.WriteFileRequest)
    case deleteFile(Protocols_FileSystemRequest.DeleteFileRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Protocols_FileSystemRequest.OneOf_Request, rhs: Protocols_FileSystemRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listFiles, .listFiles): return {
        guard case .listFiles(let l) = lhs, case .listFiles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.writeFile, .writeFile): return {
        guard case .writeFile(let l) = lhs, case .writeFile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteFile, .deleteFile): return {
        guard case .deleteFile(let l) = lhs, case .deleteFile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct InitRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `for`: Protocols_FileSystemRequest.InitRequest.OneOf_For? = nil

    var post: Protocols_FileSystemRequest.InitRequest.Post {
      get {
        if case .post(let v)? = `for` {return v}
        return Protocols_FileSystemRequest.InitRequest.Post()
      }
      set {`for` = .post(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_For: Equatable {
      case post(Protocols_FileSystemRequest.InitRequest.Post)

    #if !swift(>=4.1)
      static func ==(lhs: Protocols_FileSystemRequest.InitRequest.OneOf_For, rhs: Protocols_FileSystemRequest.InitRequest.OneOf_For) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.post, .post): return {
          guard case .post(let l) = lhs, case .post(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    struct Post {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: Int64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct ListFilesRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct WriteFileRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var spec: Protocols_FileSpec {
      get {return _spec ?? Protocols_FileSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    var hasSpec: Bool {return self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    mutating func clearSpec() {self._spec = nil}

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _spec: Protocols_FileSpec? = nil
  }

  struct DeleteFileRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _init_p: Protocols_FileSystemRequest.InitRequest? = nil
}

struct Protocols_FileSystemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var init_p: Protocols_FileSystemResponse.InitResponse {
    get {return _init_p ?? Protocols_FileSystemResponse.InitResponse()}
    set {_init_p = newValue}
  }
  /// Returns true if `init_p` has been explicitly set.
  var hasInit_p: Bool {return self._init_p != nil}
  /// Clears the value of `init_p`. Subsequent reads from it will return its default value.
  mutating func clearInit_p() {self._init_p = nil}

  var response: Protocols_FileSystemResponse.OneOf_Response? = nil

  var listFiles: Protocols_FileSystemResponse.ListFilesResponse {
    get {
      if case .listFiles(let v)? = response {return v}
      return Protocols_FileSystemResponse.ListFilesResponse()
    }
    set {response = .listFiles(newValue)}
  }

  var writeFile: Protocols_FileSystemResponse.WriteFileResponse {
    get {
      if case .writeFile(let v)? = response {return v}
      return Protocols_FileSystemResponse.WriteFileResponse()
    }
    set {response = .writeFile(newValue)}
  }

  var deleteFile: Protocols_FileSystemResponse.DeleteFileResponse {
    get {
      if case .deleteFile(let v)? = response {return v}
      return Protocols_FileSystemResponse.DeleteFileResponse()
    }
    set {response = .deleteFile(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case listFiles(Protocols_FileSystemResponse.ListFilesResponse)
    case writeFile(Protocols_FileSystemResponse.WriteFileResponse)
    case deleteFile(Protocols_FileSystemResponse.DeleteFileResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Protocols_FileSystemResponse.OneOf_Response, rhs: Protocols_FileSystemResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listFiles, .listFiles): return {
        guard case .listFiles(let l) = lhs, case .listFiles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.writeFile, .writeFile): return {
        guard case .writeFile(let l) = lhs, case .writeFile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteFile, .deleteFile): return {
        guard case .deleteFile(let l) = lhs, case .deleteFile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct InitResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ListFilesResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var files: [Protocols_FileSpec] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct WriteFileResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteFileResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _init_p: Protocols_FileSystemResponse.InitResponse? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocols_LinkKind: @unchecked Sendable {}
extension Protocols_Metas: @unchecked Sendable {}
extension Protocols_Metas.Source: @unchecked Sendable {}
extension Protocols_Metas.Geo: @unchecked Sendable {}
extension Protocols_Metas.Origin: @unchecked Sendable {}
extension Protocols_Metas.Origin.Platform: @unchecked Sendable {}
extension Protocols_Post: @unchecked Sendable {}
extension Protocols_GetPostRequest: @unchecked Sendable {}
extension Protocols_UpdatePostRequest: @unchecked Sendable {}
extension Protocols_DeletePostRequest: @unchecked Sendable {}
extension Protocols_ListPostsRequest: @unchecked Sendable {}
extension Protocols_ListPostsResponse: @unchecked Sendable {}
extension Protocols_GetPostCommentsCountRequest: @unchecked Sendable {}
extension Protocols_GetPostCommentsCountResponse: @unchecked Sendable {}
extension Protocols_SetPostStatusRequest: @unchecked Sendable {}
extension Protocols_SetPostStatusResponse: @unchecked Sendable {}
extension Protocols_GetPostCommentsRequest: @unchecked Sendable {}
extension Protocols_GetPostCommentsResponse: @unchecked Sendable {}
extension Protocols_GetPostsByTagsRequest: @unchecked Sendable {}
extension Protocols_GetPostsByTagsResponse: @unchecked Sendable {}
extension Protocols_PreviewPostRequest: @unchecked Sendable {}
extension Protocols_PreviewPostResponse: @unchecked Sendable {}
extension Protocols_CheckPostTaskListItemsRequest: @unchecked Sendable {}
extension Protocols_CheckPostTaskListItemsResponse: @unchecked Sendable {}
extension Protocols_FileSpec: @unchecked Sendable {}
extension Protocols_FileSystemRequest: @unchecked Sendable {}
extension Protocols_FileSystemRequest.OneOf_Request: @unchecked Sendable {}
extension Protocols_FileSystemRequest.InitRequest: @unchecked Sendable {}
extension Protocols_FileSystemRequest.InitRequest.OneOf_For: @unchecked Sendable {}
extension Protocols_FileSystemRequest.InitRequest.Post: @unchecked Sendable {}
extension Protocols_FileSystemRequest.ListFilesRequest: @unchecked Sendable {}
extension Protocols_FileSystemRequest.WriteFileRequest: @unchecked Sendable {}
extension Protocols_FileSystemRequest.DeleteFileRequest: @unchecked Sendable {}
extension Protocols_FileSystemResponse: @unchecked Sendable {}
extension Protocols_FileSystemResponse.OneOf_Response: @unchecked Sendable {}
extension Protocols_FileSystemResponse.InitResponse: @unchecked Sendable {}
extension Protocols_FileSystemResponse.ListFilesResponse: @unchecked Sendable {}
extension Protocols_FileSystemResponse.WriteFileResponse: @unchecked Sendable {}
extension Protocols_FileSystemResponse.DeleteFileResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocols"

extension Protocols_LinkKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LinkKindNone"),
    1: .same(proto: "LinkKindRooted"),
    2: .same(proto: "LinkKindFull"),
  ]
}

extension Protocols_Metas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metas"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "footer"),
    3: .same(proto: "outdated"),
    4: .same(proto: "wide"),
    10: .same(proto: "sources"),
    11: .same(proto: "geo"),
    12: .same(proto: "origin"),
    100: .same(proto: "weixin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.header) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.footer) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.outdated) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.wide) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Protocols_Metas.Source>.self, value: &self.sources) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._geo) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self.weixin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.header.isEmpty {
      try visitor.visitSingularStringField(value: self.header, fieldNumber: 1)
    }
    if !self.footer.isEmpty {
      try visitor.visitSingularStringField(value: self.footer, fieldNumber: 2)
    }
    if self.outdated != false {
      try visitor.visitSingularBoolField(value: self.outdated, fieldNumber: 3)
    }
    if self.wide != false {
      try visitor.visitSingularBoolField(value: self.wide, fieldNumber: 4)
    }
    if !self.sources.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Protocols_Metas.Source>.self, value: self.sources, fieldNumber: 10)
    }
    try { if let v = self._geo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.weixin.isEmpty {
      try visitor.visitSingularStringField(value: self.weixin, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_Metas, rhs: Protocols_Metas) -> Bool {
    if lhs.header != rhs.header {return false}
    if lhs.footer != rhs.footer {return false}
    if lhs.outdated != rhs.outdated {return false}
    if lhs.wide != rhs.wide {return false}
    if lhs.sources != rhs.sources {return false}
    if lhs._geo != rhs._geo {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.weixin != rhs.weixin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_Metas.Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_Metas.protoMessageName + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "description"),
    4: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_Metas.Source, rhs: Protocols_Metas.Source) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_Metas.Geo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_Metas.protoMessageName + ".Geo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "longitude"),
    3: .same(proto: "latitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.longitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.latitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 2)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_Metas.Geo, rhs: Protocols_Metas.Geo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_Metas.Origin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_Metas.protoMessageName + ".Origin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "slugs"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.slugs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .originUnspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if !self.slugs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.slugs, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_Metas.Origin, rhs: Protocols_Metas.Origin) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.slugs != rhs.slugs {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_Metas.Origin.Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OriginUnspecified"),
    1: .same(proto: "Twitter"),
  ]
}

extension Protocols_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Post"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "modified"),
    4: .same(proto: "title"),
    5: .same(proto: "content"),
    6: .same(proto: "slug"),
    7: .same(proto: "type"),
    8: .same(proto: "category"),
    9: .same(proto: "status"),
    10: .standard(proto: "page_view"),
    11: .standard(proto: "comment_status"),
    12: .same(proto: "comments"),
    13: .same(proto: "metas"),
    14: .same(proto: "source"),
    15: .standard(proto: "source_type"),
    16: .same(proto: "tags"),
    17: .standard(proto: "last_commented_at"),
    18: .same(proto: "relates"),
    19: .same(proto: "link"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _date: Int32 = 0
    var _modified: Int32 = 0
    var _title: String = String()
    var _content: String = String()
    var _slug: String = String()
    var _type: String = String()
    var _category: Int64 = 0
    var _status: String = String()
    var _pageView: Int64 = 0
    var _commentStatus: Bool = false
    var _comments: Int64 = 0
    var _metas: Protocols_Metas? = nil
    var _source: String = String()
    var _sourceType: String = String()
    var _tags: [String] = []
    var _lastCommentedAt: Int32 = 0
    var _relates: [Protocols_Post] = []
    var _link: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _date = source._date
      _modified = source._modified
      _title = source._title
      _content = source._content
      _slug = source._slug
      _type = source._type
      _category = source._category
      _status = source._status
      _pageView = source._pageView
      _commentStatus = source._commentStatus
      _comments = source._comments
      _metas = source._metas
      _source = source._source
      _sourceType = source._sourceType
      _tags = source._tags
      _lastCommentedAt = source._lastCommentedAt
      _relates = source._relates
      _link = source._link
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._date) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._modified) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._category) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._pageView) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._commentStatus) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._comments) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._metas) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._sourceType) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._lastCommentedAt) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._relates) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._link) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._date != 0 {
        try visitor.visitSingularInt32Field(value: _storage._date, fieldNumber: 2)
      }
      if _storage._modified != 0 {
        try visitor.visitSingularInt32Field(value: _storage._modified, fieldNumber: 3)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 4)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 5)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 6)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 7)
      }
      if _storage._category != 0 {
        try visitor.visitSingularInt64Field(value: _storage._category, fieldNumber: 8)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 9)
      }
      if _storage._pageView != 0 {
        try visitor.visitSingularInt64Field(value: _storage._pageView, fieldNumber: 10)
      }
      if _storage._commentStatus != false {
        try visitor.visitSingularBoolField(value: _storage._commentStatus, fieldNumber: 11)
      }
      if _storage._comments != 0 {
        try visitor.visitSingularInt64Field(value: _storage._comments, fieldNumber: 12)
      }
      try { if let v = _storage._metas {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._source.isEmpty {
        try visitor.visitSingularStringField(value: _storage._source, fieldNumber: 14)
      }
      if !_storage._sourceType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceType, fieldNumber: 15)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 16)
      }
      if _storage._lastCommentedAt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lastCommentedAt, fieldNumber: 17)
      }
      if !_storage._relates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._relates, fieldNumber: 18)
      }
      if !_storage._link.isEmpty {
        try visitor.visitSingularStringField(value: _storage._link, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_Post, rhs: Protocols_Post) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._modified != rhs_storage._modified {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._pageView != rhs_storage._pageView {return false}
        if _storage._commentStatus != rhs_storage._commentStatus {return false}
        if _storage._comments != rhs_storage._comments {return false}
        if _storage._metas != rhs_storage._metas {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._sourceType != rhs_storage._sourceType {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._lastCommentedAt != rhs_storage._lastCommentedAt {return false}
        if _storage._relates != rhs_storage._relates {return false}
        if _storage._link != rhs_storage._link {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "page"),
    99: .standard(proto: "with_relates"),
    100: .standard(proto: "content_options"),
    101: .standard(proto: "with_link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.page) }()
      case 99: try { try decoder.decodeSingularBoolField(value: &self.withRelates) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._contentOptions) }()
      case 101: try { try decoder.decodeSingularEnumField(value: &self.withLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.page.isEmpty {
      try visitor.visitSingularStringField(value: self.page, fieldNumber: 3)
    }
    if self.withRelates != false {
      try visitor.visitSingularBoolField(value: self.withRelates, fieldNumber: 99)
    }
    try { if let v = self._contentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    if self.withLink != .none {
      try visitor.visitSingularEnumField(value: self.withLink, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostRequest, rhs: Protocols_GetPostRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.page != rhs.page {return false}
    if lhs.withRelates != rhs.withRelates {return false}
    if lhs._contentOptions != rhs._contentOptions {return false}
    if lhs.withLink != rhs.withLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_UpdatePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePostRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
    2: .standard(proto: "update_mask"),
    3: .standard(proto: "do_not_touch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.doNotTouch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.doNotTouch != false {
      try visitor.visitSingularBoolField(value: self.doNotTouch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_UpdatePostRequest, rhs: Protocols_UpdatePostRequest) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.doNotTouch != rhs.doNotTouch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_DeletePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeletePostRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_DeletePostRequest, rhs: Protocols_DeletePostRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_ListPostsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPostsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .standard(proto: "order_by"),
    3: .standard(proto: "content_options"),
    4: .same(proto: "kinds"),
    5: .standard(proto: "with_link"),
    6: .standard(proto: "modified_not_before"),
    7: .standard(proto: "modified_not_after"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._contentOptions) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.kinds) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.withLink) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.modifiedNotBefore) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.modifiedNotAfter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 2)
    }
    try { if let v = self._contentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kinds, fieldNumber: 4)
    }
    if self.withLink != .none {
      try visitor.visitSingularEnumField(value: self.withLink, fieldNumber: 5)
    }
    if self.modifiedNotBefore != 0 {
      try visitor.visitSingularInt32Field(value: self.modifiedNotBefore, fieldNumber: 6)
    }
    if self.modifiedNotAfter != 0 {
      try visitor.visitSingularInt32Field(value: self.modifiedNotAfter, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_ListPostsRequest, rhs: Protocols_ListPostsRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._contentOptions != rhs._contentOptions {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.withLink != rhs.withLink {return false}
    if lhs.modifiedNotBefore != rhs.modifiedNotBefore {return false}
    if lhs.modifiedNotAfter != rhs.modifiedNotAfter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_ListPostsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPostsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "posts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.posts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.posts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_ListPostsResponse, rhs: Protocols_ListPostsResponse) -> Bool {
    if lhs.posts != rhs.posts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostCommentsCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostCommentsCountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.postID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.postID != 0 {
      try visitor.visitSingularInt64Field(value: self.postID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostCommentsCountRequest, rhs: Protocols_GetPostCommentsCountRequest) -> Bool {
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostCommentsCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostCommentsCountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostCommentsCountResponse, rhs: Protocols_GetPostCommentsCountResponse) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_SetPostStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPostStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "public"),
    3: .same(proto: "touch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.`public`) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.touch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.`public` != false {
      try visitor.visitSingularBoolField(value: self.`public`, fieldNumber: 2)
    }
    if self.touch != false {
      try visitor.visitSingularBoolField(value: self.touch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_SetPostStatusRequest, rhs: Protocols_SetPostStatusRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.`public` != rhs.`public` {return false}
    if lhs.touch != rhs.touch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_SetPostStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPostStatusResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_SetPostStatusResponse, rhs: Protocols_SetPostStatusResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostCommentsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostCommentsRequest, rhs: Protocols_GetPostCommentsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostCommentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostCommentsResponse, rhs: Protocols_GetPostCommentsResponse) -> Bool {
    if lhs.comments != rhs.comments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostsByTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostsByTagsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
    2: .standard(proto: "content_options"),
    3: .standard(proto: "with_link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contentOptions) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.withLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 1)
    }
    try { if let v = self._contentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.withLink != .none {
      try visitor.visitSingularEnumField(value: self.withLink, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostsByTagsRequest, rhs: Protocols_GetPostsByTagsRequest) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs._contentOptions != rhs._contentOptions {return false}
    if lhs.withLink != rhs.withLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_GetPostsByTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPostsByTagsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "posts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.posts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.posts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_GetPostsByTagsResponse, rhs: Protocols_GetPostsByTagsResponse) -> Bool {
    if lhs.posts != rhs.posts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_PreviewPostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreviewPostRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "markdown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.markdown) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.markdown.isEmpty {
      try visitor.visitSingularStringField(value: self.markdown, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_PreviewPostRequest, rhs: Protocols_PreviewPostRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.markdown != rhs.markdown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_PreviewPostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreviewPostResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "html"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.html) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.html.isEmpty {
      try visitor.visitSingularStringField(value: self.html, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_PreviewPostResponse, rhs: Protocols_PreviewPostResponse) -> Bool {
    if lhs.html != rhs.html {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_CheckPostTaskListItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckPostTaskListItemsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "post_modification_time"),
    10: .same(proto: "checks"),
    11: .same(proto: "unchecks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.postModificationTime) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.checks) }()
      case 11: try { try decoder.decodeRepeatedInt32Field(value: &self.unchecks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.postModificationTime != 0 {
      try visitor.visitSingularInt32Field(value: self.postModificationTime, fieldNumber: 2)
    }
    if !self.checks.isEmpty {
      try visitor.visitPackedInt32Field(value: self.checks, fieldNumber: 10)
    }
    if !self.unchecks.isEmpty {
      try visitor.visitPackedInt32Field(value: self.unchecks, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_CheckPostTaskListItemsRequest, rhs: Protocols_CheckPostTaskListItemsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.postModificationTime != rhs.postModificationTime {return false}
    if lhs.checks != rhs.checks {return false}
    if lhs.unchecks != rhs.unchecks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_CheckPostTaskListItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckPostTaskListItemsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_CheckPostTaskListItemsResponse, rhs: Protocols_CheckPostTaskListItemsResponse) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "mode"),
    3: .same(proto: "size"),
    4: .same(proto: "time"),
    5: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.time) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt32Field(value: self.time, fieldNumber: 4)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSpec, rhs: Protocols_FileSpec) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.size != rhs.size {return false}
    if lhs.time != rhs.time {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileSystemRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    10: .standard(proto: "list_files"),
    11: .standard(proto: "write_file"),
    12: .standard(proto: "delete_file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._init_p) }()
      case 10: try {
        var v: Protocols_FileSystemRequest.ListFilesRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .listFiles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .listFiles(v)
        }
      }()
      case 11: try {
        var v: Protocols_FileSystemRequest.WriteFileRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .writeFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .writeFile(v)
        }
      }()
      case 12: try {
        var v: Protocols_FileSystemRequest.DeleteFileRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteFile(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._init_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.request {
    case .listFiles?: try {
      guard case .listFiles(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .writeFile?: try {
      guard case .writeFile(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .deleteFile?: try {
      guard case .deleteFile(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemRequest, rhs: Protocols_FileSystemRequest) -> Bool {
    if lhs._init_p != rhs._init_p {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemRequest.InitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemRequest.protoMessageName + ".InitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocols_FileSystemRequest.InitRequest.Post?
        var hadOneofValue = false
        if let current = self.`for` {
          hadOneofValue = true
          if case .post(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`for` = .post(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .post(let v)? = self.`for` {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemRequest.InitRequest, rhs: Protocols_FileSystemRequest.InitRequest) -> Bool {
    if lhs.`for` != rhs.`for` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemRequest.InitRequest.Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemRequest.InitRequest.protoMessageName + ".Post"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemRequest.InitRequest.Post, rhs: Protocols_FileSystemRequest.InitRequest.Post) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemRequest.ListFilesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemRequest.protoMessageName + ".ListFilesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemRequest.ListFilesRequest, rhs: Protocols_FileSystemRequest.ListFilesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemRequest.WriteFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemRequest.protoMessageName + ".WriteFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spec"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemRequest.WriteFileRequest, rhs: Protocols_FileSystemRequest.WriteFileRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemRequest.DeleteFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemRequest.protoMessageName + ".DeleteFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemRequest.DeleteFileRequest, rhs: Protocols_FileSystemRequest.DeleteFileRequest) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileSystemResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    10: .standard(proto: "list_files"),
    11: .standard(proto: "write_file"),
    12: .standard(proto: "delete_file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._init_p) }()
      case 10: try {
        var v: Protocols_FileSystemResponse.ListFilesResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .listFiles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .listFiles(v)
        }
      }()
      case 11: try {
        var v: Protocols_FileSystemResponse.WriteFileResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .writeFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .writeFile(v)
        }
      }()
      case 12: try {
        var v: Protocols_FileSystemResponse.DeleteFileResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteFile(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._init_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.response {
    case .listFiles?: try {
      guard case .listFiles(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .writeFile?: try {
      guard case .writeFile(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .deleteFile?: try {
      guard case .deleteFile(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemResponse, rhs: Protocols_FileSystemResponse) -> Bool {
    if lhs._init_p != rhs._init_p {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemResponse.InitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemResponse.protoMessageName + ".InitResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemResponse.InitResponse, rhs: Protocols_FileSystemResponse.InitResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemResponse.ListFilesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemResponse.protoMessageName + ".ListFilesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemResponse.ListFilesResponse, rhs: Protocols_FileSystemResponse.ListFilesResponse) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemResponse.WriteFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemResponse.protoMessageName + ".WriteFileResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemResponse.WriteFileResponse, rhs: Protocols_FileSystemResponse.WriteFileResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocols_FileSystemResponse.DeleteFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocols_FileSystemResponse.protoMessageName + ".DeleteFileResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocols_FileSystemResponse.DeleteFileResponse, rhs: Protocols_FileSystemResponse.DeleteFileResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
